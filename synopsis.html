<html>
<title>synopsis</title>
<body>
<pre class="">
<p style="font-family: consolas, monospace; font-style: regular; font-size: 85%;">

&emsp;&emsp; : Moving through moon mountain <a style="font-size:18px" href="#jump-anch">jump</a> to skip &emsp; Programming is
&emsp;&emsp; sorta like one giant, stretched-out equation... &emsp; We are &emsp;&emsp; going through
&emsp;&emsp; the process of programming, creative ideas, and whatever else that may
&emsp;&emsp; entail. &emsp; It is luminary to have all possible insight into our
&emsp;&emsp; potential, as well as the possibilities &emsp; that could propagate from it.
&emsp;&emsp; These are just the basic walkthrows, in terms of thought-direction....
&emsp;&emsp; ; What are the approaches one would benefit from when starting out?
&emsp; &mdash; <em>Compare things, experiment, find alternatives, identify
&emsp;&emsp; patterns, move through the spectrum &emsp; of concepts you're concerned
&emsp;&emsp; with and make landmarks throughout your progress, if only to
&emsp; reserve in mental-vitro. Talk through a problem, and walk yourself
&emsp;&emsp; through it. Dont worry &emsp; about technical conditions, just write down
&emsp;&emsp; the basics; Documenting everything is important.</em>
&emsp;&emsp;&emsp; &emsp; i like these videos, about breadboards: &mdash; <a href="https://youtu.be/yl8vPW5hydQ">8bit breadboard</a>,
&emsp;&emsp; &mdash; <a href="https://youtu.be/I0-izyq6q5s">Latch</a>
&emsp;&emsp; &emsp; : Bits <a href="prog">=</a><a> Bytes &emsp; Operating systems use
&emsp;&emsp; paging-enabled to produce virtual memory addresses. &emsp; The system that
&emsp;&emsp; is the exhange of you and the OS deals with a programming language. All a
&emsp;&emsp; program does is &emsp; define a process; by which to transform the data
&emsp;&emsp; type primitives associated with that language. &emsp; The way I see code is
&emsp;&emsp; like a single dimension of memory, by which it gets moved around.
&emsp;&emsp; &emsp; Here's the basic assignment for a computer; It looks at lots of
&emsp;&emsp; wires at a time and reacts to an extensive &emsp; pattern of On + Off
&emsp;&emsp; switches. We represent it as; A wire that is On is "1" and a wire that is
&emsp;&emsp; Off is "0". &emsp; Then we look at the wires leading into a computer and
&emsp;&emsp; read; (from right to left)ex. 11000111 &emsp; You can represent 256 things
&emsp;&emsp; with a byte (a byte is 8 bits). &emsp; The bits in a byte have numbers.
&emsp;&emsp; The rightmost bit is bit 0, and the left hand one is bit 7.
&emsp;&emsp;&emsp; Those two bits also have names. The rightmost is the
&emsp;&emsp; least significant bit. &emsp; The leftmost within that set of bits would be
&emsp;&emsp; the most significant. &emsp; The largest number you can represent with
&emsp;&emsp; 8 bits is 11111111, or 255 in decimal notation. &emsp; 00000000 is the
&emsp;&emsp; smallest in that set. Logical operators compare bits of the given object
&emsp;&emsp;&emsp; and always return a Boolean result. Bitwise operators perform
&emsp;&emsp; operations on individual bits &emsp; and the result is also always a bit.
&emsp;&emsp; Assignment operators initialize an object with a value &emsp; or perform
&emsp;&emsp; specific operations on it. A Shifting operator will always pad with zeros
&emsp;&emsp; at the &emsp; end of the bit sequence. OR'ing just does a composite.
&emsp;&emsp; &emsp; : </a><a id="bitwise-anch"></a>Bitwise Operators<a> 
&emsp;&emsp; /* What each bit combo would result in */ &emsp; &amp; (AND operation) (0+0=0; 1+1=1; 0+1=0)
&emsp;&emsp;&emsp;&emsp; | (OR operation) (0+0=0; 1+1=1; 0+1=1)
&emsp;&emsp;&emsp; ^ (XOR operation) (0+0=0; 1+1=0; 0+1=1) &emsp; ~ (NOT operation) flips every bit &emsp;
&emsp;&emsp; &gt;&gt; (Right Shift operation) each bit to the right
&emsp;&emsp;&emsp; &lt;&lt; (Left Shift operation) each bit to the left
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <a href="https://en.wikipedia.org/wiki/Hershey%27s_Chocolate_World">Hershey's Chocolate World</a>      <a id="ascii-anch"></a><a href="ascii">ASCII</a><a> &emsp; : </a>
&emsp;&emsp;&emsp;&emsp; <a id="physical-anch"></a>Physical Memory<a>
&emsp;&emsp; &emsp; Without getting too deep, we'll just mention Random Access Memory,
&emsp;&emsp;&emsp; and how it is allocated/stored. RAM holds data that the CPU has
&emsp;&emsp; access to. &emsp; You can look at RAM as a long block of memory divided
&emsp;&emsp; into segments. &emsp; Two of those are Stack and Heap. Stack is for static
&emsp;&emsp; memory, and Heap for dynamic memory. &emsp; Stack is loaded when it knows
&emsp;&emsp; exactly how much data you need to allocate before compile time.
&emsp;&emsp;&emsp; Within the Stack, operations such as 'push' and 'pop' are performed.
&emsp;&emsp; Variables allocated on &emsp; the Heap happen at runtime.
&emsp;&emsp; Heap is application specific and Stack is thread specific.
&emsp;&emsp;&emsp; ... think of the whole process like: processing bits along a
&emsp;&emsp; structure we made... sorta like, &emsp; walking ants in a row.
&emsp;&emsp; These are special ants, that are very dedicated to instructions.
&emsp;&emsp;&emsp; The cpu, gpu, psu, etc are all part of the colony habitat.
&emsp;&emsp; The ants can be anywhere between &emsp; -2147483648 to 2147483647 or 0 to
&emsp;&emsp; 4294967295, and they have jobs to do, places to go such as @
&emsp;&emsp;&emsp; RAM, HDD, back to the colony, etc. The ants keep marching on, hoorah!
&emsp;&emsp; .. &emsp; So they march one by one and thats basically that. Now here comes
&emsp;&emsp; along another group &emsp; called </a><a href="robotinternet">floating point</a><a> ants.
&emsp;&emsp; Again, they march on &amp; on all the same, they just move in
&emsp;&emsp;&emsp; a different way than the first ants.
&emsp;&emsp;&emsp; I like this demonstration for the feel of it &mdash; </a>
&emsp;&emsp; <a href="https://woodgears.ca/marbleadd/">Binary Marble Machine</a> <a> &emsp; I pranced over a lot of the details.
&emsp;&emsp; Lots of learning/utilities exist. </a><a href="utility">Utility Reference</a>
&emsp;&emsp; <a> &emsp; : </a><a id="signed-anch"></a>Signed v Unsigned
&emsp;&emsp; <a> &emsp; A 32-bit signed integer is an integer whose value is represented
&emsp;&emsp; in 32 bits &emsp; (i.e. 4 bytes). Bits are binary, meaning they may only be
&emsp;&emsp; a zero or a one. &emsp; Thus, the 32-bit signed integer is a string of 32
&emsp;&emsp; zeros and ones. &emsp; The signed part of the integer refers to its ability
&emsp;&emsp; to represent both &emsp; positive and negative values. A positive integer
&emsp;&emsp; will have its most &emsp; significant bit (the leading bit) be a zero,
&emsp;&emsp; while a negative integer will &emsp; have its most significant bit be a one.
&emsp;&emsp; Because of this, &emsp; the most significant bit of a signed integer is
&emsp;&emsp; typically called &emsp; the &ldquo;sign bit&rdquo; since its purpose is to
&emsp;&emsp; denote the sign of the integer. &emsp; : Little Endian &emsp; A big-endian
&emsp;&emsp; system stores the most significant byte of a word at the &emsp; smallest
&emsp;&emsp; memory address and the least significant byte at the largest &emsp; memory
&emsp;&emsp; address. A little-endian system stores the least-significant byte &emsp; at
&emsp;&emsp; the smallest address... &emsp; A processor with 64-bit memory addresses can
&emsp;&emsp; directly access 2^64 bytes. &emsp; A cpu with a clock speed of 2GHz can
&emsp;&emsp; carry out two billion &emsp; cycle(<em>a pulse synchronized by an internal
&emsp;&emsp; oscillator</em>) per second. &emsp; The crystal oscillator is sending out
&emsp;&emsp; an electric pulse at speed, &emsp; millions of times per sec. You can think
&emsp;&emsp; of it as being the cpu's metronome. &emsp;
&emsp;&emsp; <!-- href="#jump-anch" --> —* /* |* \* —* 02/02/2022:  <a style="font-size:30px" href="prog"> skip</a></p>
<a id="jump-anch">
<div style="text-align: center;">
<p style="font-family: consolas, monospace; font-style: bold; font-size: 130%;">&emsp;&emsp;&emsp;Tabla Content</p>
</div>
<p style="font-family: consolas, monospace; font-style: regular; font-size: 85%; text-align: center;"> &emsp; : <a href="#bits-anch">Bits + Bytes</a> &emsp; : <a href="#bitwise-anch">Bitwise Operators</a> &emsp; : <a href="#ascii-anch">ASCII</a> &emsp; : <a href="#physical-anch">Physical Memory</a> &emsp; : <a href="#signed-anch">Signed v Unsigned</a></p>

</pre>
</body>
</html>